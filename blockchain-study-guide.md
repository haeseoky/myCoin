# 블록체인 & 솔리디티 초보자 가이드

## 목차
1. [블록체인 기본 개념](#1-블록체인-기본-개념)
2. [기존 데이터베이스와의 차이점](#2-기존-데이터베이스와의-차이점)
3. [스마트 컨트랙트 실행 주체](#3-스마트-컨트랙트-실행-주체)
4. [Gas Fee 지불 구조](#4-gas-fee-지불-구조)
5. [합의 알고리즘과 토큰 발행](#5-합의-알고리즘과-토큰-발행)
6. [P2P 네트워크 전파 메커니즘](#6-p2p-네트워크-전파-메커니즘)
7. [PoS 투표 및 합의 공유 메커니즘](#7-pos-투표-및-합의-공유-메커니즘)

---

## 1. 블록체인 기본 개념

### 🧱 블록체인이란?
- **분산 장부**: 여러 컴퓨터에 동일한 데이터를 저장하는 기술
- **불변성**: 한번 기록된 데이터는 변경이 매우 어려움
- **투명성**: 모든 거래 내역이 공개됨
- **탈중앙화**: 중앙 관리 기관 없이 운영

### 📝 스마트 컨트랙트란?
- **자동 실행**: 조건이 충족되면 자동으로 실행되는 디지털 계약
- **신뢰성**: 코드로 작성되어 조작이 불가능
- **효율성**: 중간자 없이 직접 거래 가능

### 🔹 이더리움 블록체인
- 스마트 컨트랙트를 실행할 수 있는 플랫폼
- **Gas**: 컨트랙트 실행에 필요한 수수료
- **ETH**: 이더리움의 기본 화폐

### 💡 실생활 예시
전통적인 자판기를 생각해보세요:
1. 돈을 넣는다 (조건)
2. 버튼을 누른다 (실행)
3. 음료가 나온다 (결과)

스마트 컨트랙트도 이와 같이 "조건 → 실행 → 결과"의 논리로 작동합니다.

---

## 2. 기존 데이터베이스와의 차이점

### 🏛️ **기존 데이터베이스 = 은행 장부**
```
[은행 서버 1대]
김철수: 100만원
이영희: 50만원
박민수: 200만원
```
- **중앙집중**: 은행 1곳에서 모든 장부 관리
- **수정 가능**: 은행 직원이 실수로 잔고 변경 가능
- **접근 제한**: 본인과 은행 직원만 확인 가능
- **신뢰 필요**: 은행을 믿어야 함

### 🌐 **블록체인 = 마을 공동 장부**
```
[마을 사람 100명이 각자 같은 장부 보관]
김철수: 100만원  ✓✓✓✓✓ (모든 사람이 동의)
이영희: 50만원   ✓✓✓✓✓ (모든 사람이 동의)
박민수: 200만원  ✓✓✓✓✓ (모든 사람이 동의)
```
- **분산**: 마을 사람들이 각자 똑같은 장부 보관
- **수정 불가**: 100명 중 51명 이상이 동의해야 변경 가능
- **공개**: 누구나 장부 내용 확인 가능
- **신뢰 불필요**: 다수의 합의로 진실 결정

### 🔄 **거래 과정 비교**

#### 기존 데이터베이스 (은행 송금)
1. 김철수가 이영희에게 10만원 송금 요청
2. 은행이 김철수 잔고에서 10만원 차감
3. 은행이 이영희 잔고에 10만원 추가
4. **문제점**: 은행 서버 오류 시 거래 기록 손실 가능

#### 블록체인 (암호화폐 송금)
1. 김철수가 이영희에게 10만원 송금 요청
2. 마을 사람들이 "김철수가 정말 10만원 있나?" 확인
3. 과반수가 "맞다!"고 동의하면 거래 승인
4. 모든 사람의 장부에 동시에 기록
5. **장점**: 몇 명의 장부가 사라져도 나머지가 보관

### 📊 **핵심 차이점 정리**

| 구분 | 기존 데이터베이스 | 블록체인 |
|------|------------------|----------|
| **관리자** | 은행, 정부 등 중앙기관 | 참여자 모두 |
| **장부 위치** | 중앙 서버 1곳 | 모든 참여자 컴퓨터 |
| **수정 권한** | 관리자만 | 과반수 합의 필요 |
| **투명성** | 제한적 공개 | 완전 공개 |
| **해킹 위험** | 서버 1곳만 뚫으면 끝 | 과반수를 동시에 뚫어야 함 |

---

## 3. 스마트 컨트랙트 실행 주체

### 🌐 **이더리움 네트워크 = 전 세계 컴퓨터들의 연합**

```
[전 세계 수천 대의 컴퓨터 (노드)]
한국 노드 🖥️ ← → 미국 노드 🖥️ ← → 유럽 노드 🖥️
    ↕               ↕               ↕
일본 노드 🖥️ ← → 호주 노드 🖥️ ← → 브라질 노드 🖥️
```

### 📋 **역할 분담**

#### 1️⃣ **개발자 (당신)의 역할**
- 스마트 컨트랙트 코드 작성
- 컨트랙트를 블록체인에 배포 (Deploy)
- **비유**: 앱스토어에 앱을 올리는 개발자

#### 2️⃣ **이더리움 네트워크 (광부들)의 역할**
- 스마트 컨트랙트 실행
- 거래 검증 및 블록 생성
- **비유**: 앱스토어 서버가 앱을 구동시키는 것

#### 3️⃣ **사용자의 역할**
- 컨트랙트의 함수 호출
- Gas비 지불
- **비유**: 앱을 다운받아 사용하는 일반 사용자

### 🔄 **실제 프로세스**

#### **1단계: 개발 및 배포**
```
개발자 → [스마트 컨트랙트 작성] → 이더리움 네트워크에 배포
        (Remix IDE 등에서)      (Gas비 지불하고 업로드)
```

#### **2단계: 실행**
```
사용자 → [컨트랙트 함수 호출] → 이더리움 노드들이 실행
        (MetaMask 지갑 등으로)   (수천 대 컴퓨터가 동시에)
```

### 🏗️ **실제 인프라**

#### **누가 서버를 운영하나?**
```
❌ 중앙 서버 없음
✅ 전 세계 개인들이 자발적으로 컴퓨터 제공

개인A: 집에서 이더리움 노드 운영 → Gas비 수익
개인B: 회사에서 이더리움 노드 운영 → Gas비 수익
개인C: 데이터센터에서 대규모 운영 → Gas비 수익
```

#### **왜 사람들이 노드를 운영하나?**
1. **수익**: Gas비로 돈을 벌 수 있음
2. **탈중앙화**: 자유로운 금융 시스템 지지
3. **기술적 흥미**: 블록체인 기술에 대한 관심

---

## 4. Gas Fee 지불 구조

### 💸 **Gas Fee를 지불하는 시점들**

#### 1️⃣ **배포 시 (Deploy)** - 개발자가 지불
```
개발자 → [컨트랙트 코드] → 이더리움 네트워크
        💰 Gas Fee 지불      (블록체인에 영구 저장)
```
- **비용**: 약 0.05~0.2 ETH (50~200달러 정도)
- **이유**: 컨트랙트 코드를 블록체인에 영구히 저장하는 비용

#### 2️⃣ **사용 시 (Execute)** - 사용자가 지불
```
사용자 → [함수 호출] → 이더리움 네트워크
        💰 Gas Fee 지불   (컨트랙트 실행)
```
- **비용**: 약 0.01~0.05 ETH (10~50달러 정도)
- **이유**: 컨트랙트 함수를 실행하는 비용

### 💰 **비용 부담 구조**

#### **개발자의 비용**
- ✅ **배포 비용**: 1회성 (50~200달러)
- ❌ **운영 비용**: 없음 (서버 운영비 없음!)
- ❌ **사용자 실행 비용**: 사용자가 각자 지불

#### **전통적인 앱과 비교**
```
📱 전통적인 앱:
개발자 → 앱 개발 → 서버 운영(월 수십만원) → 서비스 제공

🔗 스마트 컨트랙트:
개발자 → 컨트랙트 배포(5만원) → 끝! → 사용자들이 각자 실행
```

### 🎯 **누가 언제 Gas Fee를 내는가?**

| 행동 | 누가 | 언제 | 비용 | 예시 |
|------|------|------|------|------|
| 컨트랙트 배포 | 개발자 | 1회 | 높음 | 100달러 |
| 토큰 발행 | 개발자 | 필요시 | 중간 | 20달러 |
| 토큰 전송 | 사용자 | 매번 | 낮음 | 5달러 |
| 토큰 구매 | 사용자 | 매번 | 낮음 | 10달러 |

---

## 5. 합의 알고리즘과 토큰 발행

### 📡 **1단계: 거래 요청 브로드캐스트 (Broadcasting)**

토큰 발행자가 직접 각 노드에 "합의해달라"고 요청하는 것이 **아닙니다**!

```
토큰 발행자 → [거래 생성] → 가장 가까운 노드 1개에 전송
                                      ↓
               가까운 노드 → 모든 연결된 노드들에게 자동 전파
                                      ↓
                    전 세계 모든 노드가 거래 정보 수신
```

### ⚙️ **합의 알고리즘별 실행 과정**

#### 🔨 **PoW (작업증명) - 비트코인 방식**

**Step 1: 거래 수집**
```
각 노드(광부)들이 메모리풀에서 거래들을 모음
[토큰 발행 거래] + [다른 거래들] → 블록 후보 생성
```

**Step 2: 경쟁적 채굴**
```
광부 A: 해시값 계산 중... (컴퓨터 풀가동)
광부 B: 해시값 계산 중... (컴퓨터 풀가동)
광부 C: 해시값 계산 중... (컴퓨터 풀가동)
     ↓
광부 B가 올바른 해시값 발견! → 블록 생성
```

**Step 3: 자동 검증**
```
광부 B → [새 블록] → 다른 모든 노드들에게 전송
         ↓
다른 노드들이 자동으로 검증:
✅ 해시값이 맞나?
✅ 거래들이 유효한가?
✅ 토큰 발행 로직이 올바른가?
```

#### 🪙 **PoS (지분증명) - 이더리움 2.0 방식**

**Step 1: 검증자 선택**
```
32 ETH 이상 보유자들 중에서 무작위로 블록 생성자 선택
선택된 검증자: 노드 X
```

**Step 2: 블록 생성 및 제안**
```
노드 X → [토큰 발행 거래 포함 블록] → 다른 검증자들에게 전송
```

**Step 3: 검증자들의 투표**
```
검증자 A: ✅ 찬성 (지분: 100 ETH)
검증자 B: ✅ 찬성 (지분: 50 ETH)
검증자 C: ❌ 반대 (지분: 30 ETH)
     ↓
찬성 150 ETH vs 반대 30 ETH → 승인!
```

#### 🗳️ **DPoS (위임지분증명) - EOS 방식**

**Step 1: 미리 선출된 대표자들**
```
전체 토큰 보유자들이 21명의 대표자 선출
대표자들이 돌아가면서 블록 생성
```

**Step 2: 순서대로 블록 생성**
```
시간: 00:00 → 대표자 1번이 블록 생성
시간: 00:03 → 대표자 2번이 블록 생성
시간: 00:06 → 대표자 3번이 블록 생성
```

### 🔍 **토큰 발행 시 실제 검증 과정**

#### **각 노드가 자동으로 확인하는 것들:**

```solidity
// 토큰 발행 함수 예시
function mintTokens(address to, uint256 amount) public {
    require(msg.sender == owner, "권한 없음");     // ✅ 검증 1
    require(amount > 0, "수량이 0보다 커야 함");    // ✅ 검증 2
    totalSupply += amount;                      // ✅ 검증 3
    balances[to] += amount;                    // ✅ 검증 4
}
```

#### **모든 노드가 동시에 검증:**
1. **권한 확인**: 발행자가 정말 owner인가?
2. **로직 확인**: 컨트랙트 코드대로 실행되나?
3. **잔고 확인**: 수학적 계산이 맞나?
4. **Gas 확인**: Gas fee가 충분히 지불되었나?

---

## 6. P2P 네트워크 전파 메커니즘

### 🔗 **1. MetaMask가 어떤 노드에 연결하는가?**

#### **RPC Endpoint 설정**
MetaMask는 미리 설정된 **RPC(Remote Procedure Call) Endpoint**에 연결합니다.

```javascript
// MetaMask 기본 설정
이더리움 메인넷: https://mainnet.infura.io/v3/[API_KEY]
테스트넷: https://goerli.infura.io/v3/[API_KEY]

// 사용자가 직접 설정 가능
커스텀 RPC: https://my-ethereum-node.com:8545
로컬 노드: http://localhost:8545
```

#### **실제 연결 과정**
```
MetaMask → Infura/Alchemy 같은 노드 서비스 → 실제 이더리움 노드
            (중간 서비스)                    (풀노드)
```

### 🌐 **2. P2P 네트워크 전파 메커니즘**

#### **노드 발견 (Node Discovery)**
각 노드는 연결할 다른 노드들을 어떻게 찾을까요?

**Step 1: Bootstrap Nodes (부트스트랩 노드)**
```
// 이더리움 클라이언트에 하드코딩된 초기 노드들
bootstrap_nodes = [
    "enode://d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666@18.138.108.67:30303",
    "enode://22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de@3.209.45.79:30303"
    // ... 더 많은 부트스트랩 노드들
]
```

**Step 2: Peer Discovery Protocol**
```
새로운 노드 → 부트스트랩 노드에 연결
             ↓
부트스트랩 노드 → "내가 아는 다른 노드들 목록 줄게"
             ↓
새로운 노드 → 받은 목록의 노드들과 연결 시도
             ↓
연결된 노드들 → 또 다른 노드들 소개
```

### 📡 **3. 실제 전파 과정 (Gossip Protocol)**

#### **선택적 전파 전략**
모든 노드에게 브로드캐스트하는 것이 **아닙니다**! 매우 효율적인 방식을 사용합니다.

**Gossip Protocol 작동 방식**
```
거래 받은 노드 → 연결된 피어 중 일부만 선택 (보통 3-8개)
                ↓
선택된 피어들 → 자신의 피어 중 일부에게 전파
                ↓
지수적으로 확산 (3→9→27→81→243...)
```

#### **실제 알고리즘**

**Step 1: 피어 선택 알고리즘**
```python
# 의사코드
def select_peers_for_broadcast(all_peers, message):
    # 1. 이미 이 메시지를 받은 피어 제외
    available_peers = filter_already_received(all_peers, message)
    
    # 2. 연결 품질 기준으로 정렬
    sorted_peers = sort_by_connection_quality(available_peers)
    
    # 3. 상위 N개 선택 (보통 3-8개)
    selected_peers = sorted_peers[:BROADCAST_COUNT]
    
    return selected_peers
```

**Step 2: 중복 방지 메커니즘**
```python
# 각 노드가 관리하는 정보
received_messages = {
    "0x1a2b3c...": timestamp,  # 거래 해시 : 받은 시간
    "0x2b3c4d...": timestamp,
    # ...
}

def should_forward_message(message_hash):
    if message_hash in received_messages:
        return False  # 이미 받은 거래는 전파하지 않음
    else:
        received_messages[message_hash] = current_time()
        return True   # 새로운 거래는 전파
```

### 🎯 **실제 토큰 발행 전파 예시**

```
[시작] 한국의 MetaMask 사용자가 토큰 발행

0초: MetaMask → Infura 서울 노드
1초: Infura 서울 → 연결된 5개 피어 노드 (일본, 홍콩, 싱가포르, 호주, 미국)
2초: 5개 노드 → 각각 3-5개씩 전파 (총 15-25개 노드)
3초: 15-25개 노드 → 각각 3-5개씩 전파 (총 45-125개 노드)
4초: 45-125개 노드 → 각각 3-5개씩 전파 (총 135-625개 노드)
5초: 거의 모든 노드(수천 개)가 거래 정보 수신 완료
```

---

## 7. PoS 투표 및 합의 공유 메커니즘

### 🗳️ **PoS 투표 및 합의 공유 메커니즘 상세 분석**

PoS에서는 검증자들이 서로의 투표 결과를 공유해야 최종 합의에 도달할 수 있습니다. 이 과정을 단계별로 상세히 설명합니다.

### 📡 **1단계: 블록 제안 및 초기 전파**

#### **블록 제안자 선정**
```
시간 슬롯 #1000: 
전체 검증자 풀에서 VRF(Verifiable Random Function)로 제안자 선택

선택된 제안자: 검증자 A (지분: 100 ETH)
```

#### **블록 제안 전파**
```
검증자 A → [새 블록 제안] → 모든 검증자들에게 브로드캐스트

블록 내용:
- 이전 블록 해시: 0x1a2b3c...
- 거래 목록: [토큰 발행 거래, 다른 거래들...]
- 제안자 서명: 0x9e8f7d...
```

### 🗳️ **2단계: 검증자들의 투표 (Attestation)**

#### **각 검증자의 독립적 검증**
```
검증자 B (50 ETH): 블록 검증 중...
✅ 이전 블록 해시 확인
✅ 거래 유효성 검증
✅ 토큰 발행 로직 확인
→ 찬성 투표 결정
```

#### **투표 메시지 생성**
```javascript
// 검증자 B의 투표 메시지
attestation_B = {
    slot: 1000,
    block_hash: "0x1a2b3c...",
    vote: "APPROVE",
    validator_index: 42,
    signature: "0x8d7c6b..."  // 검증자 B의 개인키로 서명
}
```

### 📢 **3단계: 투표 결과 전파 (Vote Broadcasting)**

#### **P2P 네트워크를 통한 투표 전파**
```
검증자 B → [투표 메시지] → 연결된 다른 검증자들에게 전송
            ↓
검증자 C, D, E가 수신 → 각자의 연결된 검증자들에게 재전파
            ↓
모든 검증자가 검증자 B의 투표를 수신
```

#### **실제 전파 과정**
```
0.1초: 검증자 B가 투표 완료 → 5개 피어에게 전송
0.2초: 5개 피어가 각각 3-5개에게 재전파 (총 15-25개)
0.3초: 15-25개가 각각 재전파 (총 45-125개)
0.5초: 거의 모든 검증자(수만 개)가 투표 수신 완료
```

### 📊 **4단계: 투표 집계 및 합의 달성**

#### **각 검증자가 독립적으로 집계**
모든 검증자가 받은 투표들을 독립적으로 집계합니다:

```python
# 각 검증자의 로컬 집계
def count_votes(received_attestations):
    approve_stake = 0
    reject_stake = 0
    
    for attestation in received_attestations:
        if verify_signature(attestation):  # 서명 검증
            if attestation.vote == "APPROVE":
                approve_stake += get_validator_stake(attestation.validator_index)
            else:
                reject_stake += get_validator_stake(attestation.validator_index)
    
    return approve_stake, reject_stake

# 결과 예시
approve_stake = 24,000 ETH (75%)
reject_stake = 8,000 ETH (25%)
total_stake = 32,000 ETH

if approve_stake > total_stake * 2/3:  # 2/3 이상 찬성
    return "CONSENSUS_REACHED"
```

#### **합의 임계값 확인**
```
필요 임계값: 전체 지분의 2/3 (66.67%)
실제 찬성: 24,000 ETH / 32,000 ETH = 75%

75% > 66.67% → ✅ 합의 달성!
```

### 🔄 **5단계: 최종 확정 (Finalization)**

#### **블록 확정 전파**
```
각 검증자 → [블록 확정 메시지] → 전체 네트워크
```

#### **최종 확정 메시지**
```javascript
finalization_message = {
    slot: 1000,
    block_hash: "0x1a2b3c...",
    status: "FINALIZED",
    vote_summary: {
        approve_stake: 24000,
        reject_stake: 8000,
        total_participating: 32000
    }
}
```

### 🕐 **시간별 상세 프로세스 (이더리움 2.0 기준)**

#### **슬롯 기반 타이밍 (12초 단위)**
```
시간 0:00 - 슬롯 1000 시작
├─ 0-4초: 블록 제안자가 블록 생성 및 전파
├─ 4-8초: 검증자들이 검증 후 투표 생성 및 전파
├─ 8-12초: 모든 투표 수집 및 집계
└─ 12초: 다음 슬롯 1001 시작

시간 12:00 - 슬롯 1001 시작
├─ 이전 슬롯 결과 반영하여 새 블록 제안
└─ 동일 과정 반복
```

### 📡 **투표 전파의 기술적 세부사항**

#### **GossipSub 프로토콜 사용**
```
이더리움 2.0은 libp2p의 GossipSub 프로토콜 사용

주제별 구독:
- /eth2/beacon_block/ssz  (블록 전파)
- /eth2/beacon_attestation/ssz  (투표 전파)
- /eth2/voluntary_exit/ssz  (검증자 탈퇴)
```

#### **메시지 검증 과정**
```python
def validate_attestation(attestation):
    # 1. 서명 검증
    if not verify_bls_signature(attestation.signature):
        return False
    
    # 2. 검증자 자격 확인
    if not is_active_validator(attestation.validator_index):
        return False
    
    # 3. 슬롯 유효성 확인
    if not is_valid_slot(attestation.slot):
        return False
    
    # 4. 중복 투표 확인
    if already_voted(attestation.validator_index, attestation.slot):
        return False  # 슬래싱 대상
    
    return True
```

### ⚡ **효율성 최적화**

#### **집계 서명 (BLS Signature Aggregation)**
```
개별 투표들을 하나로 집계:

개별 투표: 검증자 A, B, C가 각각 96바이트 서명
집계 투표: A+B+C의 투표를 96바이트 하나로 압축

네트워크 트래픽 67% 감소!
```

#### **위원회 시스템 (Committee System)**
```
전체 검증자를 작은 위원회로 분할:

슬롯 1000: 위원회 1 (1000명) → 블록 A 검증
슬롯 1001: 위원회 2 (1000명) → 블록 B 검증
슬롯 1002: 위원회 3 (1000명) → 블록 C 검증

동시에 여러 위원회가 서로 다른 역할 수행
```

### 🚨 **악의적 행동 방지**

#### **슬래싱 (Slashing) 메커니즘**
```python
# 이중 투표 감지
def detect_double_voting(validator_index, slot):
    votes = get_votes_by_validator(validator_index, slot)
    
    if len(votes) > 1:
        # 동일 슬롯에 2개 이상 투표 → 슬래싱
        slash_validator(validator_index)
        confiscate_stake(validator_index, penalty=1000)  # 1000 ETH 몰수
```

#### **지연 투표 페널티**
```python
def calculate_voting_penalty(attestation):
    delay = current_slot - attestation.slot
    
    if delay > 32:  # 32슬롯(6.4분) 초과 지연
        penalty = base_reward * delay / 32
        return penalty
    
    return 0
```

### 🎯 **PoS 투표 메커니즘 핵심 포인트**

#### **투표 공유 메커니즘**
1. **P2P 전파**: GossipSub 프로토콜로 투표 메시지 전파
2. **독립 집계**: 각 검증자가 독립적으로 투표 집계
3. **임계값 확인**: 2/3 이상 합의 시 블록 확정
4. **최종 전파**: 확정 결과를 전체 네트워크에 알림

#### **효율성 최적화**
1. **BLS 집계**: 여러 서명을 하나로 압축
2. **위원회 분할**: 작업 부하 분산
3. **시간 제한**: 12초 슬롯으로 빠른 처리
4. **페널티**: 지연/악의적 행동 방지

#### **보안 메커니즘**
1. **슬래싱**: 이중 투표 등 악의적 행동 처벌
2. **서명 검증**: 모든 투표 메시지 암호학적 검증
3. **지분 기반**: 경제적 인센티브로 정직한 행동 유도

## 💡 **핵심 정리**

### **블록체인의 핵심 특징**
1. **탈중앙화**: 중앙 기관 없이 참여자들이 공동 관리
2. **투명성**: 모든 거래가 공개되어 투명함
3. **불변성**: 한번 기록된 데이터는 변경이 매우 어려움
4. **자동화**: 스마트 컨트랙트로 자동 실행

### **Gas Fee 구조**
1. **개발자**: 배포 시 1회만 Gas fee 지불
2. **사용자**: 사용할 때마다 Gas fee 지불
3. **운영비**: 배포 후 추가 운영비 없음

### **합의 알고리즘**
1. **PoW**: 컴퓨팅 파워로 경쟁하여 블록 생성
2. **PoS**: 지분에 비례하여 검증자 선택
3. **DPoS**: 위임받은 대표자들이 순서대로 블록 생성

### **네트워크 전파**
1. **노드 연결**: RPC 서비스를 통해 이더리움 네트워크 접근
2. **피어 발견**: 부트스트랩 노드로 시작해서 네트워크 구성
3. **선택적 전파**: 효율적인 Gossip Protocol로 빠른 확산
4. **중복 방지**: 메시지 해시 기반으로 중복 전파 방지

---

*이 문서는 블록체인과 솔리디티 학습을 위한 기초 가이드입니다. 다음 단계에서는 실제 솔리디티 언어와 개발 환경에 대해 학습하게 됩니다.*